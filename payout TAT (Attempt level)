
with conversion_data as (
SELECT 
    "from" AS from_currency,
    CAST(argMax(base_rate, created_at) AS Decimal(12,10)) AS rate_in_usd
FROM datalake.clean_fx_log
WHERE "to" = 'USD'
GROUP BY "from"),


payout_created AS (
SELECT payout_id, created_at AS payout_created_at, currency AS payout_currency, account_id,
if(upper(currency) = 'BTC',amount / 100000000.0,amount / 100.0) AS payout_amount,
-- Estimated USD amount
if(upper(currency) = 'BTC',(amount / 100000000.0) * toFloat64(rate_in_usd),
if(upper(currency) = 'USD',amount / 100.0,(amount / 100.0) * toFloat64(rate_in_usd))) AS estimated_payout_amount_usd
FROM datalake.clean_payout a 
LEFT JOIN conversion_data b ON upper(a.currency) = upper(b.from_currency))
-- select * from payout_created order by payout_created_at desc limit 1000
,


account_risk as (
select account_id, auto_payout_consent, auto_payout_threshold/100.0 as  auto_payout_threshold
from datalake.clean_account_risk where vendor_payout = 'enabled'
), 

-- join above two (contains all above)
account_payout as (
select a.payout_id, a.payout_created_at, a.account_id, a.payout_amount, a.estimated_payout_amount_usd, 
b.auto_payout_consent, b.auto_payout_threshold ,
case when auto_payout_consent = 'true' and estimated_payout_amount_usd <= auto_payout_threshold  then 1 else 0 end as can_be_auto_payout
from payout_created a
left join account_risk b 
on a.account_id = b.account_id
)
,
-- select * from account_payout where payout_id = 'pot_coahh0k30hnb6csf5sqg'


-- tested above
    
all_attempted as (
select payout_attempt_id, payout_id, provider, updated_by, created_at as payout_attempt_created_at, failure_code, error_code, 

status as payout_attempt_status
-- case when payout_attempt_status = 'reversed' then updated_at end as 'reversed_at'
from datalake.clean_payout_attempt
)
-- select * from account_payout
,


all_payout_and_attempts as (
select a.payout_id as payout_id, a.payout_created_at, a.account_id, a.payout_amount, a.estimated_payout_amount_usd, 
a.auto_payout_consent, a.auto_payout_threshold , a.can_be_auto_payout,

b.payout_attempt_id as payout_attempt_id, b.provider, b.payout_attempt_created_at, b.failure_code, b.error_code, 
b.payout_attempt_status, updated_by 

from account_payout a 
full outer join all_attempted b 
on a.payout_id = b.payout_id)
-- select * from all_payout_and_attempts
,

datamart as (
select payout_id, payout_attempt_id, transfer_type, txn_source, fund_transfer_network, rate_in_pcy_to_usd, destination_currency, 
seller_email, business_name
from datamart_payout
), 

transition_timeline as(
SELECT 
    payout_attempt_id,
    
    max(if("to" = 'initiated', created_at, NULL)) AS initiated_at,
    max(if("to" = 'failed', created_at, NULL)) AS failed_at,
    max(if("to" = 'processing_retry', created_at, NULL)) AS processing_retry_at,
    max(if("to" = 'compliance_hold', created_at, NULL)) AS compliance_hold_at,
    max(if("to" = 'requires_action', created_at, NULL)) AS requires_action_at,
    max(if("to" = 'succeeded', created_at, NULL)) AS succeeded_at,
     max(if("to" = 'approved', created_at, NULL)) AS approved_at,
    max(if("to" = 'processing_retry' or "from" = 'processing_retry', 1, 0)) AS was_in_processing_retry,
    -- count(if("to" = 'processing_retry' and "from" = 'processing_retry', 1, 0)) AS count_in_processing_retry,
    sum(if("to" = 'processing_retry', 1, 0)) AS count_of_in_processing_retry,
    max(if("to" = 'requires_funding' or "from" = 'requires_funding', 1, 0)) AS was_in_requires_funding,
    max(if("to" = 'initiated', created_by, NULL)) AS initiated_by,
    
    if(
        argMax(created_by, if("to" = 'succeeded', created_at, toDateTime('1970-01-01'))) = 'system',
        'auto',
        'manual'
    ) as success_trigger,
    
    -- Get created_by for the row with max created_at where "to" = 'processing_retry'
    if(
        argMax(created_by, if("to" = 'processing_retry', created_at, toDateTime('1970-01-01'))) = 'system',
        'auto',
        'manual'
    ) as processing_retry_trigger,
    
    -- Get created_by for the row with max created_at where "to" = 'failed'
    if(
        argMax(created_by, if("to" = 'failed', created_at, toDateTime('1970-01-01'))) = 'system',
        'auto',
        'manual'
    ) as failed_trigger
      -- max(if("to" = 'succeeded'and created_at = 'system', "auto", "manual")) end success_trigger,
FROM datalake.clean_payout_attempt_status_transition
GROUP BY payout_attempt_id) ,

reversal_data as (
select payout_id, created_at as reversed_at, reason as reversal_reason 
from datalake.clean_payout_reversal
),


-- al fine till above 

final as (
select 

a.payout_id as payout_id, a.payout_created_at, a.account_id, a.payout_amount, a.estimated_payout_amount_usd, 
a.auto_payout_consent, a.auto_payout_threshold , a.can_be_auto_payout,
a.payout_attempt_id as payout_attempt_id, a.provider, a.payout_attempt_created_at, a.failure_code, a.error_code, 
a.payout_attempt_status, a.updated_by, 

row_number() over(partition by a.payout_id order by payout_attempt_created_at asc) as attempt_num,
row_number() over(partition by a.payout_id order by payout_attempt_created_at desc) as attempt_num_desc,

initiated_at, failed_at, processing_retry_at, compliance_hold_at, requires_action_at,
succeeded_at, was_in_processing_retry, was_in_requires_funding, approved_at, count_of_in_processing_retry,
success_trigger, processing_retry_trigger, failed_trigger, initiated_by,

transfer_type, txn_source, fund_transfer_network, rate_in_pcy_to_usd, seller_email, business_name, destination_currency, 

arrayStringConcat(
    arrayFilter(
        x -> x != '',
        array(
            if(failed_at > succeeded_at , 'failed_to_succeeded', ''),
            if(count_of_in_processing_retry > 1, 'count_of_in_processing_retry > 1', ''),
            if(failed_at > approved_at, 'failed_to_approved', ''),
            if(processing_retry_at > succeeded_at, 'processing_retry_to_succeeded', ''),
            if(succeeded_at > failed_at, 'succeeded_to_failed', ''),
            if(processing_retry_at > failed_at, 'processing_retry_to_failed', '')
        )
    ),
    ' - '
) AS abnormal_state_list,

case when failed_at > succeeded_at   then 'abnormal_state'
when count_of_in_processing_retry > 1 then 'abnormal_state'
when failed_at > approved_at then 'abnormal_sate'
when processing_retry_at > succeeded_at then 'abnormal_state'
when succeeded_at > failed_at then 'abnormal_state'
when processing_retry_at > failed_at then 'abnormal_state' end as fl_abnormal_state,

 CASE WHEN 
    (provider = 'yesbank' AND transfer_type = 'local' AND destination_currency IN ('DZD', 'AUD'))
    OR (provider = 'zamp' AND destination_currency IN ('USDT', 'USDC'))
    OR (provider = 'fuse' AND transfer_type = 'local' AND destination_currency = 'TRY')
    OR (provider = 'cellulant' AND transfer_type = 'swift' AND destination_currency = 'EUR')
    OR (provider = 'yesbank' AND transfer_type = 'swift' AND destination_currency = 'INR')
    OR (provider in ('na','neo'))
THEN 0 
ELSE 1 
END AS fl_api_integrated,

nullIf(if(attempt_num_desc = 1, reversed_at, toDateTime('1970-01-01')), toDateTime('1970-01-01')) AS reversed_at,
if(attempt_num_desc = 1, reversal_reason, null) as reversal_reason

-- case when can_be_auto_payout = 1 and initiated_by in ('system','n8n_ops+1@tazapay.com') 


-- fl_auto_manual_payout_final



from all_payout_and_attempts a 
left join transition_timeline b
on a.payout_attempt_id = b.payout_attempt_id
left join datamart d on a.payout_id = d.payout_id 
left join reversal_data e on a.payout_id = e.payout_id

where seller_email not like '%tazapay.com' and seller_email not like '%digitrade.com' 
-- stp, button click, manual 

)
-- select * from final limit 10


-- all fine till above 
, 

all as (
select a.*, 
dateDiff('second',initiated_at, succeeded_at) as success_tat_seconds,
dateDiff('second',initiated_at, failed_at) as failure_tat_seconds,
dateDiff('second',initiated_at, reversed_at) as reversal_tat_seconds,


CASE 
    -- Note: Put the more specific condition (with attempt_num > 1) FIRST
    WHEN can_be_auto_payout = 1 AND fl_api_integrated = 1 AND initiated_by IN ('system','n8n_ops+1@tazapay.com') 
    AND attempt_num > 1 THEN 'button_click'
    WHEN can_be_auto_payout = 1 AND fl_api_integrated = 1 AND initiated_by IN ('system','n8n_ops+1@tazapay.com') THEN 'stp'
    WHEN can_be_auto_payout = 1 AND fl_api_integrated = 0 AND initiated_by NOT IN ('system','n8n_ops+1@tazapay.com') THEN 'manual'
    WHEN can_be_auto_payout = 0 AND fl_api_integrated = 1 AND initiated_by IN ('system','n8n_ops+1@tazapay.com') THEN 'button_click'
    
    WHEN can_be_auto_payout = 0 AND fl_api_integrated = 0 AND initiated_by NOT IN ('system','n8n_ops+1@tazapay.com') THEN 'manual'
    WHEN can_be_auto_payout = 1 AND fl_api_integrated = 1 AND initiated_by NOT IN ('system','n8n_ops+1@tazapay.com') 
    THEN 'auto_payout_addressed_manually'
    when payout_attempt_id <> '' and initiated_by is null and (succeeded_at <> '' or failed_at <> '' or was_in_processing_retry = 1) then 'manual'
    when payout_attempt_id <> '' and initiated_by is null then 'not_initiated'
    -- WHEN can_be_auto_payout = 0 AND fl_api_integrated = 1 AND initiated_by IN ('system','n8n_ops+1@tazapay.com') THEN 'button_click'
    ELSE NULL
END AS fl_payout_inititate_type

-- some of fl_api_integrated = 1 and initiated_by manual and attempt_num 1,2  to be addressed

from final  a 

) 

select * from all 
